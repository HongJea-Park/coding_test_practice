# 스타 수열

[링크](https://programmers.co.kr/learn/courses/30/lessons/70130#)

<br>

## 문제 설명

다음과 같은 것들을 정의합니다.

- 어떤 수열 x의 부분 수열(Subsequence)이란, x의 몇몇 원소들을 제거하거나 그러지 않고 남은 원소들이 원래 순서를 유지하여 얻을 수 있는 새로운 수열을 말합니다.

    - 예를 들어, `[1,3]` 은 `[1,2,3,4,5]` 의 부분수열입니다. 원래 수열에서 2, 4, 5를 제거해서 얻을 수 있기 때문입니다.

- 다음과 같은 조건을 모두 만족하는 수열 x를 스타 수열이라고 정의합니다.

    - x의 길이가 2 이상의 짝수입니다. (빈 수열은 허용되지 않습니다.)
    - x의 길이를 2n이라 할 때, 다음과 같은 n개의 집합 `{x[0], x[1]}, {x[2], x[3]}, ..., {x[2n-2], x[2n-1]}` 의 교집합의 원소의 개수가 1 이상입니다.
    - `x[0] != x[1], x[2] != x[3], ..., x[2n-2] != x[2n-1]` 입니다.
    - 예를 들어, `[1,2,1,3,4,1,1,3]` 은 스타 수열입니다. `{1,2}, {1,3}, {4,1}, {1,3}` 의 교집합은 `{1}` 이고, 각 집합 내의 숫자들이 서로 다르기 때문입니다.

<br>

1차원 정수 배열 a가 매개변수로 주어집니다. a의 모든 부분 수열 중에서 가장 길이가 긴 스타 수열의 길이를 return 하도록 solution 함수를 완성해주세요. 이때, a의 모든 부분 수열 중에서 스타 수열이 없다면, 0을 return 해주세요.

<br>

## 제한사항

- a의 길이는 1 이상 500,000 이하입니다.
    - a의 모든 수는 0 이상 (a의 길이) 미만입니다.

<br>

## 입출력 예
| a	| result |
| :- | :-: |
| `[0]` |	0 |
| `[5,2,3,3,5,3]` |	4 |
| `[0,3,3,0,7,2,0,2,2,0]` |	8 |

<br>

### 입출력 예 설명

1. 입출력 예 #1

    a의 부분 수열 중에서 주어진 조건을 모두 만족하는 스타 수열이 없으므로, 0을 return 해야 합니다.
    
2. 입출력 예 #2

    `[5,2,5,3]`, `[5,3,3,5]` 는 a의 부분 수열인 동시에 스타 수열입니다. a의 부분 수열 중 이보다 더 긴 스타 수열은 없으므로, 4를 return 해야 합니다.

3. 입출력 예 #3

    `[0,3,3,0,7,0,2,0]` 는 a의 부분 수열인 동시에 스타 수열입니다. a의 부분 수열 중 이보다 더 긴 스타 수열은 없으므로, 8을 return 해야 합니다.

<br>
<br>
<br>

# Solution

별로 어렵지 않은 것 같으나 이해하기가 매우 어려운 문제였다. 이 문제에서 가장 키 포인트는 스타 수열의 조건 중 2번 째 조건에서 언급되는 교집합의 원소의 개수가 1 이상이라는 것이다. 교집합의 원소의 개수가 1 이상이기 위해서는 공통적으로 포함되는 원소가 존재해야하기 때문에 주어진 list `a` 의 원소들을 count한 뒤 가장 많이 등장한 원소들로 부분 집합들을 만들면 된다.

하지만 여기서 고려해야 할 부분이 2가지 있다.

1. 많이 등장한 원소들의 수가 복수인 경우, 어떤 원소를 선택하느냐에 따라 스타 수열의 길이가 달라질 수 있다.
2. 길이가 동일한 스타 수열이라 할지라도 그 종류는 다수일 수 있다. 이 들을 모두 구분짓기 위해서는 two pointer를 활용해야 한다. 하지만 본 문제에서는 최대 길이만 return해주면 되기 때문에 이를 고려할 필요가 없고, 하나의 index만 활용해도 된다.

<br>

```python
from collections import Counter


def solution(a):
    answer = 0
    lenA = len(a)
    count = Counter(a).most_common()
    for key, cnt in count:
        if cnt < answer:
            continue
        setCnt, idx = 0, 0
        while idx < lenA-1:
            if key not in a[idx:idx+2] or a[idx] == a[idx+1]:
                idx += 1
                continue
            setCnt += 2
            idx += 2
        answer = setCnt if setCnt > answer else answer
    return answer
```

![solution](https://i.imgur.com/4LoAzTV.png)