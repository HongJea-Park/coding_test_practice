# 괄호 회전하기

[링크](https://programmers.co.kr/learn/courses/30/lessons/76502)

<br>

## 문제 설명

다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.

- `()`, `[]`, `{}` 는 모두 올바른 괄호 문자열입니다.
- 만약 `A`가 올바른 괄호 문자열이라면, `(A)`, `[A]`, `{A}` 도 올바른 괄호 문자열입니다. 

    예를 들어, `[]` 가 올바른 괄호 문자열이므로, `([])` 도 올바른 괄호 문자열입니다.

- 만약 `A`, `B`가 올바른 괄호 문자열이라면, `AB` 도 올바른 괄호 문자열입니다.

    예를 들어, `{}` 와 `([])` 가 올바른 괄호 문자열이므로, `{}([])` 도 올바른 괄호 문자열입니다.

대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 `s`가 매개변수로 주어집니다. 이 `s`를 왼쪽으로 x (0 ≤ x < (`s`의 길이)) 칸만큼 회전시켰을 때 `s`가 올바른 괄호 문자열이 되게 하는 x의 개수를 return 하도록 solution 함수를 완성해주세요.

<br>

## 제한사항

- s의 길이는 1 이상 1,000 이하입니다.

<br>

## 입출력 예

| s	| result |
| :-: | :-: |
| `"[](){}"` |	3 |
| `"}]()[{"` |	2 |
| `"[)(]"`	| 0 |
| `"}}}"` |	0 |

<br>

## 입출력 예 설명

1. 입출력 예 #1

    다음 표는 "[](){}" 를 회전시킨 모습을 나타낸 것입니다.
    
    | x	| s를 왼쪽으로 x칸만큼 회전 |	올바른 괄호 문자열? |
    | :-: | :-: | :-: |
    | 0	| `"[](){}"` |	O |
    | 1	| `"](){}["` |	X |
    | 2	| `"(){}[]"` |	O |
    | 3	| `"){}[]("` |	X |
    | 4	| `"{}[]()"` |	O |
    | 5	| `"}[](){"` | 	X |

    올바른 괄호 문자열이 되는 x가 3개이므로, 3을 return 해야 합니다.

<br>

2. 입출력 예 #2

    다음 표는 "}]()[{" 를 회전시킨 모습을 나타낸 것입니다.
    | x	| s를 왼쪽으로 x칸만큼 회전 |	올바른 괄호 문자열? |
    | :-: | :-: | :-: |
    | 0	| `"}]()[{"` |	X |
    | 1	| `"]()[{}"` |	X |
    | 2	| `"()[{}]"` |	O |
    | 3	| `")[{}]("` |	X |
    | 4	| `"[{}]()"` |	O |
    | 5	| `"{}]()["` | 	X |
    
    올바른 괄호 문자열이 되는 x가 2개이므로, 2를 return 해야 합니다.

<br>

3. 입출력 예 #3

    s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다.

<br>

4. 입출력 예 #4

    s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다.


<br>
<br>
<br>

# Solution

문자열 `s`의 길이는 최대 1000이다. 회전은 총 1000회이며, 문자열을 매번 검사할 때 1000번 검사를 하기 때문에 최대 1000000번 반복하게 된다. 그렇기 때문에 효율성은 고려하지 않아도 문제를 해결할 수 있다.

다만, 효율성을 조금이라도 고려하기 위해 첫 문자열이나 마지막 문자열이 올바른 문자열이 아닌 경우를 미리 확인해주면 효율성을 더욱 향상시킬 수 있다.

```python
from collections import deque


def solution(s):
    def check(s):
        s = s.copy()
        if s[0] in [')', ']', '}'] or s[-1] in ['(', '[', '{']:
            return False
        stack = [s.pop()]
        while s:
            last = s.pop()
            if stack and last+stack[-1] in ['()', '[]', '{}']:
                stack.pop()
            else:
                stack.append(last)
        return True if not stack else False
    
    s = deque(s)
    answer = 0
    for _ in range(len(s)):
        answer += 1 if check(s) else 0
        s.rotate(-1)
    return answer
```
![solution](https://i.imgur.com/U0PdmWS.png)